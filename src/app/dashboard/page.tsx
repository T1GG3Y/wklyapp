'use client';

import { useCollection, useDoc, useUser, useFirestore } from '@/firebase';
import { Button } from '@/components/ui/button';
import { Receipt, ArrowDownLeft, ArrowUpRight, Edit } from 'lucide-react';
import Link from 'next/link';
import { useMemo, useEffect, useRef, useCallback } from 'react';
import type { DocumentData, Timestamp as FirestoreTimestamp } from 'firebase/firestore';
import { collection, query, where, getDocs, setDoc, doc, addDoc, Timestamp } from 'firebase/firestore';
import { startOfWeek, endOfWeek, isWithinInterval, format, subWeeks, subMonths, subYears, startOfMonth, startOfYear, isBefore, addWeeks, addMonths, addYears } from 'date-fns';
import { cn } from '@/lib/utils';
import { PageHeader } from '@/components/PageHeader';
import { HamburgerMenu } from '@/components/HamburgerMenu';
import { HealthScoreCircles, SimpleHealthCircle } from '@/components/HealthScoreCircles';
import { formatCurrency } from '@/lib/format';
import { CATEGORY_TYPE_NAMES } from '@/lib/constants';

interface IncomeSource extends DocumentData {
  id: string;
  name: string;
  amount: number;
  frequency: 'Weekly' | 'Bi-weekly' | 'Monthly' | 'Yearly';
}

interface RequiredExpense extends DocumentData {
  id: string;
  category: string;
  amount: number;
  frequency: 'Weekly' | 'Monthly' | 'Yearly';
}

interface Loan extends DocumentData {
  id: string;
  name: string;
  totalBalance: number;
  paymentFrequency: 'Weekly' | 'Monthly';
}

interface DiscretionaryExpense extends DocumentData {
  id: string;
  category: string;
  plannedAmount: number;
}

interface SavingsGoal extends DocumentData {
  id: string;
  name: string;
  targetAmount: number;
  currentAmount: number;
}

interface Transaction extends DocumentData {
  id: string;
  type: 'Income' | 'Expense';
  amount: number;
  date: FirestoreTimestamp;
  category: string;
  description?: string;
  autoGenerated?: boolean;
  sourceId?: string;
}

interface UserProfile extends DocumentData {
  startDayOfWeek?: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';
}

interface WeeklySummary extends DocumentData {
  safeToSpendRollover?: number;
  needToSpendRollover?: number;
}

// Budget Balance Circle Component
const BudgetBalanceCircle = ({
  onBudgetAmount,
  overBudgetAmount,
  label
}: {
  onBudgetAmount: number;
  overBudgetAmount: number;
  label: string;
}) => {
  const total = onBudgetAmount + overBudgetAmount;
  const greenPercent = total > 0 ? (onBudgetAmount / total) * 100 : 100;
  const isHealthy = overBudgetAmount <= 0;

  return (
    <div className="flex flex-col items-center gap-3">
      <div className="relative">
        <svg width={120} height={120} className="transform -rotate-90">
          {/* Background circle */}
          <circle
            cx={60}
            cy={60}
            r={54}
            fill="none"
            stroke="hsl(var(--muted) / 0.3)"
            strokeWidth={12}
          />
          {isHealthy ? (
            /* All green when healthy */
            <circle
              cx={60}
              cy={60}
              r={54}
              fill="none"
              stroke="hsl(142, 76%, 45%)"
              strokeWidth={12}
              strokeDasharray={`${2 * Math.PI * 54}`}
              strokeLinecap="round"
            />
          ) : (
            <>
              {/* Red portion (over budget) */}
              <circle
                cx={60}
                cy={60}
                r={54}
                fill="none"
                stroke="hsl(0, 62.8%, 50%)"
                strokeWidth={12}
                strokeDasharray={`${2 * Math.PI * 54}`}
              />
              {/* Green portion (on budget) */}
              <circle
                cx={60}
                cy={60}
                r={54}
                fill="none"
                stroke="hsl(142, 76%, 45%)"
                strokeWidth={12}
                strokeDasharray={`${(greenPercent / 100) * 2 * Math.PI * 54} ${2 * Math.PI * 54}`}
                strokeLinecap="round"
              />
            </>
          )}
        </svg>
        <div className="absolute inset-0 flex flex-col items-center justify-center">
          <p className={cn(
            "text-2xl font-black tracking-tight font-headline",
            isHealthy ? "text-green-500" : "text-foreground"
          )}>
            {formatCurrency(onBudgetAmount - overBudgetAmount)}
          </p>
          <p className="text-xs text-muted-foreground">balance</p>
        </div>
      </div>
      <p className="text-sm font-semibold text-muted-foreground text-center">{label}</p>
    </div>
  );
};

export default function DashboardScreen() {
  const { user } = useUser();
  const firestore = useFirestore();
  const hasCheckedSummaries = useRef(false);
  const hasGeneratedRecurring = useRef(false);
  const dayIndexMap: Record<string, 0 | 1 | 2 | 3 | 4 | 5 | 6> = {
    Sunday: 0, Monday: 1, Tuesday: 2, Wednesday: 3, Thursday: 4, Friday: 5, Saturday: 6
  };

  const userProfilePath = useMemo(() => (user ? `users/${user.uid}` : null), [user]);
  const incomeSourcesPath = useMemo(() => (user ? `users/${user.uid}/incomeSources` : null), [user]);
  const requiredExpensesPath = useMemo(() => (user ? `users/${user.uid}/requiredExpenses` : null), [user]);
  const discretionaryExpensesPath = useMemo(() => (user ? `users/${user.uid}/discretionaryExpenses` : null), [user]);
  const loansPath = useMemo(() => (user ? `users/${user.uid}/loans` : null), [user]);
  const savingsGoalsPath = useMemo(() => (user ? `users/${user.uid}/savingsGoals` : null), [user]);
  const transactionsPath = useMemo(() => (user ? `users/${user.uid}/transactions` : null), [user]);
  const weeklySummariesPath = useMemo(() => (user ? `users/${user.uid}/weeklySummaries` : null), [user]);

  const { data: userProfile } = useDoc<UserProfile>(userProfilePath);
  const { data: incomeSources } = useCollection<IncomeSource>(incomeSourcesPath);
  const { data: requiredExpenses } = useCollection<RequiredExpense>(requiredExpensesPath);
  const { data: discretionaryExpenses } = useCollection<DiscretionaryExpense>(discretionaryExpensesPath);
  const { data: loans } = useCollection<Loan>(loansPath);
  const { data: savingsGoals } = useCollection<SavingsGoal>(savingsGoalsPath);
  const { data: transactions } = useCollection<Transaction>(transactionsPath, { orderBy: ['date', 'desc'], limit: 15 });
  const { data: weeklySummaries } = useCollection<WeeklySummary>(weeklySummariesPath, { orderBy: ['weekStartDate', 'desc'], limit: 1 });

  const lastWeekSummary = useMemo(() => (weeklySummaries && weeklySummaries.length > 0 ? weeklySummaries[0] : null), [weeklySummaries]);

  const getWeeklyAmount = (amount: number, frequency: string) => {
    switch (frequency) {
      case 'Weekly': return amount;
      case 'Bi-weekly': return amount / 2;
      case 'Monthly': return amount / 4.33;
      case 'Yearly': return amount / 52;
      default: return 0;
    }
  };

  const weeklyCalculations = useMemo(() => {
    const weeklyIncome = (incomeSources || []).reduce((total, source) => {
      return total + getWeeklyAmount(source.amount, source.frequency);
    }, 0);

    const weeklyRequiredExpenses = (requiredExpenses || []).reduce((total, expense) => {
      return total + getWeeklyAmount(expense.amount, expense.frequency);
    }, 0);

    const weeklyPlannedDiscretionary = (discretionaryExpenses || []).reduce((total, expense) => {
      return total + expense.plannedAmount;
    }, 0);

    const weeklyLoanPayments = (loans || []).reduce((total, loan) => {
      // Assuming loans have a payment amount field - adjust as needed
      return total;
    }, 0);

    const totalSavingsTarget = (savingsGoals || []).reduce((total, goal) => {
      return total + goal.targetAmount;
    }, 0);

    const totalSavedAmount = (savingsGoals || []).reduce((total, goal) => {
      return total + goal.currentAmount;
    }, 0);

    // Calculate total budget and spending
    const totalWeeklyBudget = weeklyIncome;
    const totalWeeklyExpenses = weeklyRequiredExpenses + weeklyPlannedDiscretionary;
    const weeklyBalance = weeklyIncome - totalWeeklyExpenses;

    // Calculate on-budget vs over-budget amounts
    const onBudgetAmount = Math.max(0, weeklyBalance);
    const overBudgetAmount = Math.max(0, -weeklyBalance);

    return {
      weeklyIncome,
      weeklyRequiredExpenses,
      weeklyPlannedDiscretionary,
      totalWeeklyBudget,
      totalWeeklyExpenses,
      weeklyBalance,
      onBudgetAmount,
      overBudgetAmount,
      totalSavingsTarget,
      totalSavedAmount,
    };
  }, [incomeSources, requiredExpenses, discretionaryExpenses, loans, savingsGoals]);

  // Calculate health scores for each category
  const healthScores = useMemo(() => {
    const { weeklyRequiredExpenses, weeklyPlannedDiscretionary, weeklyIncome } = weeklyCalculations;

    // For now, simplified health calculation
    // In a full implementation, this would compare actual spending vs budgeted
    const essentialHealth = weeklyRequiredExpenses <= weeklyIncome * 0.5;
    const discretionaryHealth = weeklyPlannedDiscretionary <= weeklyIncome * 0.3;
    const savingsHealth = (savingsGoals || []).length > 0;
    const loansHealth = (loans || []).length === 0 || true; // Simplified - would check payment status

    return [
      {
        name: CATEGORY_TYPE_NAMES.essential,
        onBudgetAmount: essentialHealth ? weeklyRequiredExpenses : 0,
        overBudgetAmount: essentialHealth ? 0 : weeklyRequiredExpenses * 0.1
      },
      {
        name: CATEGORY_TYPE_NAMES.discretionary,
        onBudgetAmount: discretionaryHealth ? weeklyPlannedDiscretionary : 0,
        overBudgetAmount: discretionaryHealth ? 0 : weeklyPlannedDiscretionary * 0.1
      },
      {
        name: CATEGORY_TYPE_NAMES.savings,
        onBudgetAmount: weeklyCalculations.totalSavedAmount,
        overBudgetAmount: 0
      },
      {
        name: CATEGORY_TYPE_NAMES.loans,
        onBudgetAmount: loansHealth ? 100 : 0,
        overBudgetAmount: loansHealth ? 0 : 50
      },
    ];
  }, [weeklyCalculations, savingsGoals, loans]);

  // Auto-generate weekly summaries for past weeks
  const generateMissingSummaries = useCallback(async () => {
    if (!firestore || !user || !userProfile || hasCheckedSummaries.current) return;

    try {
      const startDay = userProfile?.startDayOfWeek || 'Sunday';
      const weekStartsOn = dayIndexMap[startDay];
      const now = new Date();
      const currentWeekStart = startOfWeek(now, { weekStartsOn });

      const summariesRef = collection(firestore, `users/${user.uid}/weeklySummaries`);
      const summariesSnapshot = await getDocs(summariesRef);
      const existingSummaryDates = new Set(
        summariesSnapshot.docs.map(doc => doc.data().weekStartDate)
      );

      const transactionsRef = collection(firestore, `users/${user.uid}/transactions`);
      const transactionsSnapshot = await getDocs(transactionsRef);
      const allTransactions = transactionsSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Transaction[];

      const weeksToCheck = 12;
      for (let i = 1; i <= weeksToCheck; i++) {
        const weekStart = subWeeks(currentWeekStart, i);
        const weekEnd = endOfWeek(weekStart, { weekStartsOn });
        const weekStartStr = format(weekStart, 'yyyy-MM-dd');
        const weekEndStr = format(weekEnd, 'yyyy-MM-dd');

        if (existingSummaryDates.has(weekStartStr)) continue;

        let totalIncome = 0;
        let totalExpenses = 0;

        for (const t of allTransactions) {
          if (!t.date) continue;
          const transactionDate = t.date.toDate();
          if (isWithinInterval(transactionDate, { start: weekStart, end: weekEnd })) {
            if (t.type === 'Income') {
              totalIncome += t.amount;
            } else {
              totalExpenses += t.amount;
            }
          }
        }

        if (totalIncome > 0 || totalExpenses > 0) {
          const summaryDoc = doc(firestore, `users/${user.uid}/weeklySummaries`, weekStartStr);
          await setDoc(summaryDoc, {
            weekStartDate: weekStartStr,
            weekEndDate: weekEndStr,
            totalIncome,
            totalExpenses,
            createdAt: new Date().toISOString(),
            userProfileId: user.uid,
          });
        }
      }

      // Only mark as checked after successful completion
      hasCheckedSummaries.current = true;
    } catch (error) {
      console.error('Error generating weekly summaries:', error);
      // Don't set hasCheckedSummaries so it will retry on next visit
    }
  }, [firestore, user, userProfile, dayIndexMap]);

  useEffect(() => {
    if (user && userProfile && firestore) {
      generateMissingSummaries();
    }
  }, [user, userProfile, firestore, generateMissingSummaries]);

  // Auto-generate recurring transactions based on income sources
  const generateRecurringTransactions = useCallback(async () => {
    if (!firestore || !user || !incomeSources || hasGeneratedRecurring.current) return;

    try {
      const transactionsRef = collection(firestore, `users/${user.uid}/transactions`);
      const now = new Date();
      let transactionsCreated = 0;

      for (const source of incomeSources) {
        // Check for existing auto-generated transactions for this source
        const existingQuery = query(
          transactionsRef,
          where('autoGenerated', '==', true),
          where('sourceId', '==', source.id)
        );
        const existingSnapshot = await getDocs(existingQuery);
        const existingTransactions = existingSnapshot.docs.map(d => ({
          ...d.data(),
          date: d.data().date?.toDate()
        }));

        // Find the most recent auto-generated transaction for this source
        let lastTransactionDate: Date | null = null;
        for (const t of existingTransactions) {
          if (t.date && (!lastTransactionDate || t.date > lastTransactionDate)) {
            lastTransactionDate = t.date;
          }
        }

        // If no auto-generated transactions exist, start from when the source was likely created
        // We'll generate for the past 8 weeks to catch up
        if (!lastTransactionDate) {
          lastTransactionDate = subWeeks(now, 8);
        }

        // Calculate periods to generate based on frequency
        const getNextDate = (date: Date, frequency: string): Date => {
          switch (frequency) {
            case 'Weekly': return addWeeks(date, 1);
            case 'Bi-weekly': return addWeeks(date, 2);
            case 'Monthly': return addMonths(date, 1);
            case 'Yearly': return addYears(date, 1);
            default: return addMonths(date, 1);
          }
        };

        // Generate missing transactions
        let nextDate = getNextDate(lastTransactionDate, source.frequency);
        while (isBefore(nextDate, now)) {
          await addDoc(transactionsRef, {
            type: 'Income',
            amount: source.amount,
            description: `${source.name} (auto-generated)`,
            category: 'Income',
            date: Timestamp.fromDate(nextDate),
            createdAt: Timestamp.now(),
            autoGenerated: true,
            sourceId: source.id,
            userProfileId: user.uid,
          });
          transactionsCreated++;
          nextDate = getNextDate(nextDate, source.frequency);
        }
      }

      if (transactionsCreated > 0) {
        console.log(`Auto-generated ${transactionsCreated} recurring income transactions`);
      }

      hasGeneratedRecurring.current = true;
    } catch (error) {
      console.error('Error generating recurring transactions:', error);
    }
  }, [firestore, user, incomeSources]);

  useEffect(() => {
    if (user && firestore && incomeSources && incomeSources.length > 0) {
      generateRecurringTransactions();
    }
  }, [user, firestore, incomeSources, generateRecurringTransactions]);

  const { onBudgetAmount, overBudgetAmount } = weeklyCalculations;

  return (
    <>
      <PageHeader
        title="HOME"
        rightContent={<HamburgerMenu />}
      />
      <main className="flex-1 overflow-y-auto no-scrollbar px-4 pb-8 space-y-5 pt-4">
        {/* Total Weekly Budget Balance */}
        <div className="glass rounded-3xl p-6 flex flex-col items-center">
          <BudgetBalanceCircle
            onBudgetAmount={onBudgetAmount}
            overBudgetAmount={overBudgetAmount}
            label="Total Weekly Budget Balance"
          />
        </div>

        {/* Health Score Section */}
        <HealthScoreCircles categories={healthScores} />

        {/* Recent Transactions */}
        <div className="glass rounded-3xl p-5">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-3">
              <div className="w-9 h-9 rounded-xl gradient-primary flex items-center justify-center">
                <Receipt className="text-white h-5 w-5" />
              </div>
              <h2 className="text-lg font-bold font-headline text-foreground">
                Recent Transactions
              </h2>
            </div>
          </div>
          <div className="flex flex-col items-center text-center mb-6">
            <Button asChild className="w-full" size="lg">
              <Link href="/transaction/new">Add a transaction</Link>
            </Button>
          </div>

          <div className="space-y-1">
            {transactions && transactions.length > 0 ? (
              transactions.map((transaction) => (
                <Link key={transaction.id} href={`/transaction/edit/${transaction.id}`} className="block group">
                  <div className="flex items-center gap-4 p-2 rounded-lg group-hover:bg-muted">
                    <div className={cn(
                      "size-10 rounded-lg flex items-center justify-center",
                      transaction.type === 'Income' ? 'bg-primary/10' : 'bg-secondary/10'
                    )}>
                      {transaction.type === 'Income' ? (
                        <ArrowUpRight className="text-primary" />
                      ) : (
                        <ArrowDownLeft className="text-secondary" />
                      )}
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="font-semibold text-foreground truncate">
                        {transaction.description || transaction.category}
                      </p>
                      <p className="text-xs text-muted-foreground">
                        {transaction.date ? format(transaction.date.toDate(), 'MMM d, yyyy') : ''}
                      </p>
                    </div>
                    <p className={cn(
                      "font-bold text-lg",
                      transaction.type === 'Income' ? 'text-primary' : 'text-secondary'
                    )}>
                      {transaction.type === 'Income' ? '+' : '-'}{formatCurrency(transaction.amount)}
                    </p>
                    <Edit className="size-4 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity" />
                  </div>
                </Link>
              ))
            ) : (
              <p className="text-center text-muted-foreground py-4">No recent transactions.</p>
            )}
          </div>
        </div>
      </main>
    </>
  );
}
